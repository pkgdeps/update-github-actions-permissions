import * as child_process from "child_process";
import * as os from "os";
import path from "path";
import * as fs from "fs/promises";
import * as globby from "globby";
import yaml from "yaml";
import type { GhPermissions, GhPermissionsDefinition, GhPermissionTypes } from "../src/types.js";
import url from "node:url";

const __filename__ = url.fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename__);

/**
 * step-security code is licensed under GPL v3
 * https://github.com/step-security/secure-repo/blob/main/LICENSE
 */
const REPOSITORY = "https://github.com/step-security/secure-repo";
const OUTPUT_FILE_PATH = path.join(__dirname, "../third-party/step-security.yml");
const IGNORE_PATTERNS = [
    "/knowledge-base/actions/azure/docker-login/action-security.yml",
    "/knowledge-base/actions/irongut/codecoveragesummary/action-security.yml"
];
const SupportedPermissionKeys: (keyof GhPermissionTypes)[] = [
    "actions",
    "checks",
    "contents",
    "pull-requests",
    "deployments",
    "issues",
    "packages",
    "repository-projects",
    "security-events",
    "statuses",
    "pages"
];

const existDirectory = async (dir: string) => {
    try {
        await fs.access(dir);
        return true;
    } catch {
        return false;
    }
};

const parsePermission = (actionContentYaml: string, filePath: string): GhPermissions => {
    if (IGNORE_PATTERNS.some((pattern) => filePath.endsWith(pattern))) {
        return {};
    }
    try {
        const result = yaml.parse(actionContentYaml);
        const permissionsProperty = result?.["github-token"]?.["permissions"] ?? {};
        return Object.fromEntries(
            Object.entries(permissionsProperty).filter(([key]) => {
                // @ts-expect-error: string is not union types
                return SupportedPermissionKeys.includes(key);
            })
        );
    } catch (error) {
        console.warn("Parse error @ " + filePath, error);
        return {};
    }
};
const pullStepSecurity = async () => {
    const workingDirectory = path.join(os.tmpdir(), "step-security");
    console.log("Working directory:", workingDirectory);
    const hasDir = await existDirectory(workingDirectory);
    if (hasDir) {
        console.log("Already cloned: " + workingDirectory);
    } else {
        console.log("Try to clone:", REPOSITORY + " to " + workingDirectory);
        await fs.mkdir(workingDirectory, {
            recursive: true
        });
        // git clone to tmpdir
        await new Promise<void>((resolve, reject) => {
            child_process.execFile("git", ["clone", "--depth", "1", REPOSITORY, workingDirectory], (error) => {
                if (error) {
                    reject(error);
                } else {
                    resolve();
                }
            });
        });
    }
    // find knowledge-base/actions/<action-name>/action-security.yml
    const files = await globby.globby([`${workingDirectory}/knowledge-base/actions/**/action-security.yml`]);
    console.log("Found files:", files.length);
    const permissionMap = new Map<string, GhPermissionsDefinition>();
    for (const filePath of files) {
        const match = filePath.match(/knowledge-base\/actions\/(?<actionName>.*)\/action-security.yml/);
        if (!match?.groups) {
            continue;
        }
        const { actionName } = match.groups;
        if (!actionName) {
            continue;
        }
        const actionContent = await fs.readFile(filePath, "utf-8");
        const permissions = parsePermission(actionContent, filePath);
        permissionMap.set(actionName, { permissions });
    }
    console.log("Found valid actions:", permissionMap.size);
    return `# This file is generated by scripts/pull-step-security.ts
# This file license is GNU Affero General Public License v3.0 ©️StepSecurity
# https://github.com/step-security/secure-repo

${yaml.stringify(Object.fromEntries(permissionMap.entries()), { sortMapEntries: true })}`;
};

pullStepSecurity()
    .then((def) => {
        return fs.writeFile(OUTPUT_FILE_PATH, def, "utf-8");
    })
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });
